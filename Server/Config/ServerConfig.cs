using System;
using System.IO;
using System.Security.Cryptography;
using Shared.Utilities;

namespace Server.Config
{
    public sealed class ServerConfig
    {
        public string ListenIp { get; set; } = "0.0.0.0";
        public int Port { get; set; } = 5000;
        public int MaxConnections { get; set; } = 512;

        // Not used for transport right now (we're not doing AES-GCM on the wire).
        // Keep as a server secret / future token seed.
        public bool EnableEncryption { get; set; } = true;

        // 32-byte key (Base64). Autogenerated on first run if blank/invalid.
        public string EncryptionKeyBase64 { get; set; } = "";

        public string LogDirectory { get; set; } =
            Path.Combine(BaseDir, "logs");

        public string? DatabaseConnectionString { get; set; }

        public static string BaseDir =>
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                         "MirageMUD", "Server");

        public static string PathFile => Path.Combine(BaseDir, "server.config.json");

        public static ServerConfig Load()
        {
            Directory.CreateDirectory(BaseDir); // ensure folder exists up-front

            var cfg = JsonConfig.LoadOrCreate(PathFile, () => new ServerConfig());

            // Generate/repair a 32-byte key (Base64)
            if (!TryDecodeKey(cfg.EncryptionKeyBase64, out _))
            {
                var key = new byte[32];
                RandomNumberGenerator.Fill(key);
                cfg.EncryptionKeyBase64 = Convert.ToBase64String(key);
                cfg.Save();
            }

            Directory.CreateDirectory(cfg.LogDirectory);
            return cfg;
        }

        public void Save() => JsonConfig.Save(PathFile, this);

        public byte[] GetEncryptionKey()
        {
            if (!TryDecodeKey(EncryptionKeyBase64, out var key))
                throw new InvalidOperationException("EncryptionKeyBase64 is invalid.");
            return key;
        }

        private static bool TryDecodeKey(string? b64, out byte[] key)
        {
            key = Array.Empty<byte>();
            if (string.IsNullOrWhiteSpace(b64)) return false;
            try
            {
                key = Convert.FromBase64String(b64);
                return key.Length == 32;
            }
            catch { return false; }
        }
    }
}